# 宣言的アーキテクチャへの移行タスク一覧

## 1. はじめに

本ドキュメントは、現在の実装（`yujihama/demo_platform`）を、合意された「宣言的アーキテクチャ」へと移行するための、詳細なタスク一覧を定義する。開発は3つの主要フェーズに分割され、各フェーズの完了は「UIを含めた具体的な動作確認」をもって定義される。これにより、段階的かつ着実な移行を実現する。

## 2. 移行の全体像

現在の「コードジェネレーター」モデルから、YAMLを解釈する「汎用実行エンジン」モデルへと移行する。

- **現状**: `config/invoice.yaml` → Jinja2テンプレート → **新しいアプリのソースコードを生成**
- **移行後**: ユーザー要求 → LLM → `workflow.yaml` → **汎用実行エンジンが解釈・実行**

## 3. フェーズ1：基盤構築と静的実行

**目標**: 手動で作成した単一の`workflow.yaml`を、新しい「汎用実行エンジン」が解釈し、バックエンド処理を実行できる状態を確立する。この段階では、UIはYAMLの`ui`セクションを解釈せず、静的な表示のみを行う。

**完了条件**: `docker-compose up`を実行後、ブラウザでアクセスすると、フロントエンドがバックエンドにAPIリクエストを送信し、バックエンドが`workflow.yaml`に基づいてDifyモックサーバーを呼び出し、その固定レスポンスをフロントエンドが画面に表示できること。

| No. | 担当 | タスク内容 | 既存コードからの変更点・特記事項 |
| :-- | :--- | :--- | :--- |
| 1.1 | **全体** | プロジェクトのブランチを作成し、新しいディレクトリ構造を準備する。 | `backend/app/`内の多くをリファクタリングするため、`backend_engine/`のような新しいディレクトリで作業を開始することを推奨。 |
| 1.2 | **Backend** | **Difyモックサーバー**をFastAPIで実装する。 | 新規作成。リクエストに応じて動的なレスポンス（例：`{"input_param": "{{request.param}}"}`）を返す機能を持つ。 |
| 1.3 | **Backend** | **汎用実行エンジンのコア**を実装する。YAMLパーサーとコンポーネントレジストリを含む。 | `backend/app/services/packaging.py`や`pipeline.py`は**廃止**。YAMLを解釈する新しいロジックを実装する。 |
| 1.4 | **Backend** | `call_workflow`コンポーネントを実装する。 | `workflows`セクションの`provider`（`dify` or `mock`）と`endpoint`を解釈し、APIを呼び分けるロジックを実装する。 |
| 1.5 | **Config** | **`workflow.yaml`のv1スキーマ**を定義する。手動で単一の`workflow.yaml`を作成する。 | `config/examples/invoice.yaml`を参考に、`info`, `workflows`, `pipeline`セクションを持つ新しいスキーマを設計する。 |
| 1.6 | **Frontend** | UIを大幅に簡素化し、バックエンドの単一エンドポイントを呼び出して結果を表示するだけの**静的な画面**に改修する。 | `frontend/src/components/WizardStepper.tsx`などの動的生成ロジックを一時的に無効化・削除する。 |
| 1.7 | **Infra** | `docker-compose.yml`を更新し、「汎用実行エンジン」「汎用フロントエンド」「Difyモックサーバー」の3つのサービスを起動できるようにする。 | `templates/docker/`配下のJinja2テンプレートは**廃止**。固定の`docker-compose.yml`に置き換える。 |

## 4. フェーズ2：動的UIと状態管理

**目標**: フロントエンドが`workflow.yaml`の`ui`セクションを解釈して動的にUIをレンダリングし、バックエンドが複数ステップにまたがる処理の状態をデータベースで管理できる状態を確立する。

**完了条件**: `workflow.yaml`に定義された複数ステップのウィザードUI（例：①ファイルアップロード → ②結果表示）がブラウザに表示され、実際にファイルをアップロードすると、処理が実行され、次のステップで結果が表示されること。処理中にブラウザをリロードしても、状態が失われないこと。

| No. | 担当 | タスク内容 | 既存コードからの変更点・特記事項 |
| :-- | :--- | :--- | :--- |
| 2.1 | **Backend** | **状態管理DB（Redis）**を導入し、セッション管理（`session_id`の発行）と中間結果の保存・復元ロジックを実装する。 | 新規作成。`jobs.py`の思想を発展させ、より汎用的な状態管理機構を構築する。 |
| 2.2 | **Backend** | `for_each`や`file_uploader`など、基本的なパイプラインコンポーネントを実装する。 | 新規作成。各コンポーネントは、実行エンジンのコンテキスト（状態）を読み書きできるように設計する。 |
| 2.3 | **Config** | `workflow.yaml`のスキーマを拡張し、**`ui`セクション**（レイアウト、ステップ、入力・出力コンポーネント定義）を追加する。 | 新規作成。`table`, `file_upload`, `button`など、基本的なUIコンポーネントの型を定義する。 |
| 2.4 | **Frontend** | **YAML UIレンダラー**を実装する。`ui`セクションを解釈し、Reactコンポーネントを動的に生成する。 | `frontend/src/components/WizardStepper.tsx`を再設計・復活させ、YAMLに基づいてステップとコンポーネントを描画する。 |
| 2.5 | **Frontend** | バックエンドとの通信を**セッションベース**に変更する。`session_id`をリクエストに含め、非同期処理の進捗をポーリングする機構を実装する。 | `frontend/src/hooks/useJobPolling.ts`を参考に、より汎用的なポーリングフックを実装する。 |
| 2.6 | **Infra** | `docker-compose.yml`に**Redisサービス**を追加する。 | Redisコンテナを新たに追加し、実行エンジンが接続できるように設定する。 |

## 5. フェーズ3：LLM統合と最終パッケージング

**目標**: LLMエージェントがユーザーの自然言語指示から`workflow.yaml`を生成し、エンドユーザーがそのアプリケーションを自身の環境で簡単に実行できる状態を完成させる。

**完了条件**: ユーザーが「請求書アプリを作って」と指示すると、LLMが`workflow.yaml`を生成する。そのYAMLを含むパッケージをダウンロードし、ユーザーが`docker-compose up`を実行すると、指定通りのUIと機能を持つアプリが起動し、本物のDify APIと連携して動作すること。

| No. | 担当 | タスク内容 | 既存コードからの変更点・特記事項 |
| :-- | :--- | :--- | :--- |
| 3.1 | **LLM** | **LLMエージェント群**（Analyst, Architect, Specialist, Validator）のプロンプトと協調動作ロジックを実装する。 | `AGENTS.md`の定義を刷新。コード生成ではなく、`workflow.yaml`のスキーマに基づいたYAML生成を行うようにプロンプトを全面的に書き換える。 |
| 3.2 | **LLM** | **スキーマバリデーター**と**自己修正ループ**のロジックを実装する。 | 新規作成。生成されたYAMLをPydanticモデルなどで検証し、エラーがあればLLMにフィードバックする機構を構築する。 |
| 3.3 | **Backend** | **アプリケーションのパッケージング機能**を実装する。生成された`workflow.yaml`と、汎用の`docker-compose.yml`, `.env`テンプレートをzipファイルにまとめてダウンロードさせるAPIを構築する。 | `backend/app/services/packaging.py`のロジックを参考にしつつ、ソースコードではなく設定ファイルをパッケージングするように改修する。 |
| 3.4 | **Frontend** | **LLMとの対話UI**を実装する。ユーザーがプロンプトを入力し、生成されたYAMLを確認・ダウンロードできる画面を作成する。 | 既存のUIをベースに、LLMとのチャットインターフェースや、生成されたYAMLのプレビュー機能などを追加する。 |
| 3.5 | **Config** | **`.env`ファイル**でDifyのAPIキーや`WORKFLOW_PROVIDER`を管理する仕組みを確定させる。 | 実行エンジンと`docker-compose.yml`が`.env`ファイルを正しく読み込むように設定を最終化する。 |
| 3.6 | **Testing** | **E2Eテスト**を更新する。LLMによるYAML生成から、パッケージのダウンロード、`docker-compose up`でのアプリ起動、そして実際のアプリ操作までを一気通貫でテストする。 | `tests/e2e/`配下のテストシナリオを、新しいアーキテクチャに合わせて全面的に書き換える。 |

## 6. フェーズ3：実装進捗状況

### 実装完了項目

- ✅ **3.1 LLMエージェント群の実装**
  - `backend/app/agents/workflow_agents.py` に以下を実装完了：
    - `AnalystAgent`: 要件分析エージェント
    - `ArchitectAgent`: アーキテクチャ設計エージェント
    - `YAMLSpecialistAgent`: YAML生成エージェント
    - `ValidatorAgent`: バリデーションエージェント
  - 協調動作ロジックを`WorkflowGenerationPipeline`に実装

- ✅ **3.2 スキーマバリデーターと自己修正ループ**
  - `backend/app/models/workflow.py` にWorkflowYamlスキーマモデルを実装
  - `backend/app/services/workflow_validator.py` に以下を実装：
    - `WorkflowValidator`: YAMLスキーマ検証とLLM検証
    - `SelfCorrectionLoop`: 自己修正ループ機構（最大3回の試行）

- ✅ **3.3 アプリケーションのパッケージング機能**
  - `backend/app/services/workflow_packaging.py` に以下を実装：
    - `WorkflowPackagingService`: workflow.yaml、docker-compose.yml、.env.example、README.mdを含むパッケージング
  - `backend/app/services/workflow_pipeline.py` にパイプライン実装完了

### 実装中・未実装項目

- 🔄 **3.4 LLMとの対話UI（フロントエンド）**
  - フロントエンドのチャットインターフェース実装が必要
  - 生成されたYAMLのプレビュー機能の実装が必要

- 🔄 **3.5 .envファイル管理仕組み**
  - docker-compose.ymlで.envファイルを正しく読み込む設定を確認・最終化が必要
  - 実行エンジンが環境変数を正しく読み込むことを確認

- 🔄 **3.6 E2Eテストの更新**
  - 新しいアーキテクチャに合わせたテストシナリオの作成が必要

### 実装詳細

#### 実装されたファイル

1. **`backend/app/models/workflow.py`**
   - `WorkflowYaml`: workflow.yamlの完全なスキーマ定義
   - `WorkflowInfo`, `WorkflowsSection`, `UISection`, `PipelineSection` など

2. **`backend/app/agents/workflow_agents.py`**
   - Phase3で要求される4つのエージェント（Analyst, Architect, Specialist, Validator）を実装
   - 各エージェントのプロンプトと協調動作ロジック

3. **`backend/app/services/workflow_validator.py`**
   - スキーマバリデーション（Pydanticモデルによる）
   - LLMによる検証
   - 自己修正ループ機構

4. **`backend/app/services/workflow_packaging.py`**
   - workflow.yamlベースのアプリケーションのパッケージング
   - docker-compose.yml、.env.example、README.mdの自動生成

5. **`backend/app/services/workflow_pipeline.py`**
   - エージェント群を協調させるパイプライン実装

### 次のステップ

1. APIエンドポイントの更新（workflow_pipelineを使用）
2. フロントエンドUIの実装（3.4）
3. .env管理の最終化（3.5）
4. E2Eテストの作成（3.6）

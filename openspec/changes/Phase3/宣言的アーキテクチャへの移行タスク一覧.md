# 宣言的アーキテクチャへの移行タスク一覧

## 1. はじめに

本ドキュメントは、現在の実装（`yujihama/demo_platform`）を、合意された「宣言的アーキテクチャ」へと移行するための、詳細なタスク一覧を定義する。開発は3つの主要フェーズに分割され、各フェーズの完了は「UIを含めた具体的な動作確認」をもって定義される。これにより、段階的かつ着実な移行を実現する。

## 2. 移行の全体像

現在の「コードジェネレーター」モデルから、YAMLを解釈する「汎用実行エンジン」モデルへと移行する。

- **現状**: `config/invoice.yaml` → Jinja2テンプレート → **新しいアプリのソースコードを生成**
- **移行後**: ユーザー要求 → LLM → `workflow.yaml` → **汎用実行エンジンが解釈・実行**

## 3. フェーズ1：基盤構築と静的実行

**目標**: 手動で作成した単一の`workflow.yaml`を、新しい「汎用実行エンジン」が解釈し、バックエンド処理を実行できる状態を確立する。この段階では、UIはYAMLの`ui`セクションを解釈せず、静的な表示のみを行う。

**完了条件**: `docker-compose up`を実行後、ブラウザでアクセスすると、フロントエンドがバックエンドにAPIリクエストを送信し、バックエンドが`workflow.yaml`に基づいてDifyモックサーバーを呼び出し、その固定レスポンスをフロントエンドが画面に表示できること。

| No. | 担当 | タスク内容 | 既存コードからの変更点・特記事項 |
| :-- | :--- | :--- | :--- |
| 1.1 | **全体** | プロジェクトのブランチを作成し、新しいディレクトリ構造を準備する。 | `backend/app/`内の多くをリファクタリングするため、`backend_engine/`のような新しいディレクトリで作業を開始することを推奨。 |
| 1.2 | **Backend** | **Difyモックサーバー**をFastAPIで実装する。 | 新規作成。リクエストに応じて動的なレスポンス（例：`{"input_param": "{{request.param}}"}`）を返す機能を持つ。 |
| 1.3 | **Backend** | **汎用実行エンジンのコア**を実装する。YAMLパーサーとコンポーネントレジストリを含む。 | `backend/app/services/packaging.py`や`pipeline.py`は**廃止**。YAMLを解釈する新しいロジックを実装する。 |
| 1.4 | **Backend** | `call_workflow`コンポーネントを実装する。 | `workflows`セクションの`provider`（`dify` or `mock`）と`endpoint`を解釈し、APIを呼び分けるロジックを実装する。 |
| 1.5 | **Config** | **`workflow.yaml`のv1スキーマ**を定義する。手動で単一の`workflow.yaml`を作成する。 | `config/examples/invoice.yaml`を参考に、`info`, `workflows`, `pipeline`セクションを持つ新しいスキーマを設計する。 |
| 1.6 | **Frontend** | UIを大幅に簡素化し、バックエンドの単一エンドポイントを呼び出して結果を表示するだけの**静的な画面**に改修する。 | `frontend/src/components/WizardStepper.tsx`などの動的生成ロジックを一時的に無効化・削除する。 |
| 1.7 | **Infra** | `docker-compose.yml`を更新し、「汎用実行エンジン」「汎用フロントエンド」「Difyモックサーバー」の3つのサービスを起動できるようにする。 | `templates/docker/`配下のJinja2テンプレートは**廃止**。固定の`docker-compose.yml`に置き換える。 |

## 4. フェーズ2：動的UIと状態管理

**目標**: フロントエンドが`workflow.yaml`の`ui`セクションを解釈して動的にUIをレンダリングし、バックエンドが複数ステップにまたがる処理の状態をデータベースで管理できる状態を確立する。

**完了条件**: `workflow.yaml`に定義された複数ステップのウィザードUI（例：①ファイルアップロード → ②結果表示）がブラウザに表示され、実際にファイルをアップロードすると、処理が実行され、次のステップで結果が表示されること。処理中にブラウザをリロードしても、状態が失われないこと。

| No. | 担当 | タスク内容 | 既存コードからの変更点・特記事項 |
| :-- | :--- | :--- | :--- |
| 2.1 | **Backend** | **状態管理DB（Redis）**を導入し、セッション管理（`session_id`の発行）と中間結果の保存・復元ロジックを実装する。 | 新規作成。`jobs.py`の思想を発展させ、より汎用的な状態管理機構を構築する。 |
| 2.2 | **Backend** | `for_each`や`file_uploader`など、基本的なパイプラインコンポーネントを実装する。 | 新規作成。各コンポーネントは、実行エンジンのコンテキスト（状態）を読み書きできるように設計する。 |
| 2.3 | **Config** | `workflow.yaml`のスキーマを拡張し、**`ui`セクション**（レイアウト、ステップ、入力・出力コンポーネント定義）を追加する。 | 新規作成。`table`, `file_upload`, `button`など、基本的なUIコンポーネントの型を定義する。 |
| 2.4 | **Frontend** | **YAML UIレンダラー**を実装する。`ui`セクションを解釈し、Reactコンポーネントを動的に生成する。 | `frontend/src/components/WizardStepper.tsx`を再設計・復活させ、YAMLに基づいてステップとコンポーネントを描画する。 |
| 2.5 | **Frontend** | バックエンドとの通信を**セッションベース**に変更する。`session_id`をリクエストに含め、非同期処理の進捗をポーリングする機構を実装する。 | `frontend/src/hooks/useJobPolling.ts`を参考に、より汎用的なポーリングフックを実装する。 |
| 2.6 | **Infra** | `docker-compose.yml`に**Redisサービス**を追加する。 | Redisコンテナを新たに追加し、実行エンジンが接続できるように設定する。 |

## 5. フェーズ3：LLM統合と最終パッケージング

**目標**: LLMエージェントがユーザーの自然言語指示から`workflow.yaml`を生成し、エンドユーザーがそのアプリケーションを自身の環境で簡単に実行できる状態を完成させる。

**完了条件**: ユーザーが「請求書アプリを作って」と指示すると、LLMが`workflow.yaml`を生成する。そのYAMLを含むパッケージをダウンロードし、ユーザーが`docker-compose up`を実行すると、指定通りのUIと機能を持つアプリが起動し、本物のDify APIと連携して動作すること。

| No. | 担当 | タスク内容 | 既存コードからの変更点・特記事項 |
| :-- | :--- | :--- | :--- |
| 3.1 | **LLM** | **LLMエージェント群**（Analyst, Architect, Specialist, Validator）のプロンプトと協調動作ロジックを実装する。 | `AGENTS.md`の定義を刷新。コード生成ではなく、`workflow.yaml`のスキーマに基づいたYAML生成を行うようにプロンプトを全面的に書き換える。 |
| 3.2 | **LLM** | **スキーマバリデーター**と**自己修正ループ**のロジックを実装する。 | 新規作成。生成されたYAMLをPydanticモデルなどで検証し、エラーがあればLLMにフィードバックする機構を構築する。 |
| 3.3 | **Backend** | **アプリケーションのパッケージング機能**を実装する。生成された`workflow.yaml`と、汎用の`docker-compose.yml`, `.env`テンプレートをzipファイルにまとめてダウンロードさせるAPIを構築する。 | `backend/app/services/packaging.py`のロジックを参考にしつつ、ソースコードではなく設定ファイルをパッケージングするように改修する。 |
| 3.4 | **Frontend** | **LLMとの対話UI**を実装する。ユーザーがプロンプトを入力し、生成されたYAMLを確認・ダウンロードできる画面を作成する。 | 既存のUIをベースに、LLMとのチャットインターフェースや、生成されたYAMLのプレビュー機能などを追加する。 |
| 3.5 | **Config** | **`.env`ファイル**でDifyのAPIキーや`WORKFLOW_PROVIDER`を管理する仕組みを確定させる。 | 実行エンジンと`docker-compose.yml`が`.env`ファイルを正しく読み込むように設定を最終化する。 |
| 3.6 | **Testing** | **E2Eテスト**を更新する。LLMによるYAML生成から、パッケージのダウンロード、`docker-compose up`でのアプリ起動、そして実際のアプリ操作までを一気通貫でテストする。 | `tests/e2e/`配下のテストシナリオを、新しいアーキテクチャに合わせて全面的に書き換える。 |

### フェーズ3 進捗メモ（2025-11-01 更新）
- [x] 3.1 LLMエージェント群: `Analyst/Architect/Specialist/Validator` を実装し、`WorkflowGenerationService` で連携させた。
- [x] 3.2 スキーマバリデーション: `WorkflowSpecification` のPydantic検証とHTTP 422ハンドリングを追加。
- [x] 3.3 パッケージング機能: 汎用 `docker-compose.yml` と `.env.template` を含むZIP生成を実装。
- [x] 3.4 フロントエンドUI: プロンプト入力・エージェントログ・YAMLプレビュー・ダウンロード導線を備えた新UIに刷新。
- [ ] 3.5 `.env`管理: 実行エンジン/composeの環境変数仕様整理と本番向け切替フローの整備が未完。
- [ ] 3.6 E2Eテスト: 新アーキテクチャに沿った通しテストの更新が未着手。
